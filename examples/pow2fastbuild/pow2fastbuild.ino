// pow2fastbuild.ino
// build "pow2fast.h"
// not really an example

#include <Arduino.h>
#include <math.h>

typedef union fiunion
{
  int32_t i;
  float   f;
} fiUNION;

typedef union wdw
{
  uint32_t dw;
  uint16t  w[2];
} WDW;

// initialize pow2tab lookup table
//   values stored are 2 ^ [0.0 .. 1.0] == 1.0 .. 2.0
//                     - 1              == 0.0 .. 1.0
// 
// this offset (1.0) is added back in in the call to pow2
// 
// the table stores only the 23-bit mantissa, hence the scaling by 2^23
// the values will always be positive, so we could/do use uint's
// 
// for int32_t, only the lowest 23 bits of the int32_t are used
//   we could use an "int24_t" (if it existed) and save 256 bytes (256 24-bit entries vs. 256 32-bit entries)
// 
// for uint16_t, the 16 bits are the highest 16 bits of the value
//   the lowest 7 bits are discarded
//   on calls to pow2fast(), these low 7 bits are 0's, so there will be a loss of precision and therefore a loss of accuracy
//   though the (decimal) precision of a float is about 6~7 digits
// 
// for int8_t, the 8 bits are the highest 8 bits of the value
//   the lowest 15 bits are discarded
//   on calls to pow2fast(), these low 15 bits are 0's, so there will be a loss of precision and therefore a loss of accuracy
// 

// the precision could be increased, but for every additional bit, the table size is doubled AND the table elements are increased
// e.g. 10 bits ==> 1024 entries * 10 bits = 1280 bytes + additional complexity for storing and retrieving the 2 additional bits
//           or ..  1024 entries * 16 bits = 2048 bytes - simpler storing and retrieving but more memory required [as in the Digital VCO by Eric Brombaugh]
//      12 bits     4096 entries * 16 bits = 8192 bytes

// we could also interpolate between stored values
// it would easist to use interpolates of 2, 4, 8, etc.
// however, since this function was designed to calculate powers of 2 originating from 10-bit ADC inputs, we wouldn't be seeing any resolution finer than 1024

// since we have a 1 V / octave response
// could build a table with 240 entries?
// this would provide 20 values between each note

uint16_t pow2tab[tabsize];

void build_pow2tab( void )
{
  const float _2p        = 256.0;                // 2^8         256.0           
  const float step       = 1.0 / _2p;            //               0.00390625    
  const float _2p23      = 8388608.0;            // 2^23    8388608.0           0x800000  100000000000000000000000
  const float _2p23_1    = _2p23 - 1.0;          //         8388607.0           0x7FFFFF  011111111111111111111111

        float zeroToOne  = 1.0 / ( _2p * 2.0 );  //               0.001953125                                       start at 1/512
        float f;
        WDW   p;

  // step along table elements and x-axis positions
  for ( int i = 0; i < tabsize; ++i )
  {
    f      = ( pow( 2.0, zeroToOne ) - 1.0 ) * _2p23;  // less 1.0, scaled by 2^23  ** the mantissa is the the same whether 1 is subtracted or not
    p.dw   = uint32_t( ( f < _2p23 ) ? f : _2p23_1 );  // as an int
    p.dw >>= 7;                                        // 23 bit mantissa ..
    pow2tab[i] = p.w[1];                               // store only the 16 high bits

    zeroToOne += step;                                 // next table entry
  }
}

char strbuf[32] = { 0 };

void setup( void )
{
  Serial.begin( 9600 );
  while ( !Serial ) { /* wait */ }

  Serial.println( "// pow2fast.h" );
  Serial.println( "// powers of 2 for 256 values [0.0 ..1.0) with 16 bit precision" );
  Serial.println( "// this file is programatically generated by examples/pow2fastbuild" );
  Serial.println();
  Serial.println( "#include <Arduino.h>" );
  Serial.println( "#include <avr/pgmspace.h>" );
  Serial.println();
  Serial.println( "float pow2fast( float x );" );
  Serial.println();
  Serial.println( "static const uint16_t pow2tab[] PROGMEM =" );
  Serial.println( "{" );

  build_pow2tab();

  Serial.print( "  " );
  uint16_t i = 0;
  do
  {
    snprintf( strbuf, sizeof(strbuf), "0x%04X", pow2tab[i] );
    Serial.print( strbuf );
    i++;
    if ( i == tabsize )       Serial.println();
    else if ( i % 16 == 0 ) { Serial.println( "," ); Serial.print( "  " ); }
    else                      Serial.print(   ", " );
  } while ( i < tabsize );

  Serial.println( "};" );
  Serial.println();
}

void loop( void )
{
  // empty
}

